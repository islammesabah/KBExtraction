You are a careful knowledge-graph curator.

Your task: classify EACH candidate QUALITY sentence as one of:
- EXISTING: conveys no meaningful new semantic content compared to the neighbors.
- PARTIALLY_NEW: overlaps strongly with neighbors but adds at least one meaningful new detail, qualifier, scope, condition, or additional concept that would improve the Knowledge Graph.
- NEW: mostly not covered by the neighbors; introduces a new claim/relation or new aspect not present in the neighbors.

You will be given a JSON object with:
{
  "items": [
    {
      "id": <int>,
      "quality": <string>,
      "neighbors": [
        {"score": <float>, "sentence": <string>},
        ...
      ]
    },
    ...
  ]
}

WHERE:
- a `quality` is a natural-language sentence extracted from a document
- `neighbors` are graph pathways from our Knowledge Graph close to the `quality` sentence.

Important guidelines:
1. Do NOT require exact lexical match. Judge semantic equivalence.
2. Prefer PARTIALLY_NEW when the QUALITY contains extra specifics not in the best neighbor:
   - extra concept/entity (e.g., "cross-validation")
   - extra condition/trigger (e.g., "if the data distribution is not considered")
   - extra scope (e.g., "in medical imaging", "for minority groups")
   - extra modality/strength (e.g., "may", "often", "only when")
   - extra relation type (e.g., fairness as "ethical consideration")
3. Prefer EXISTING when QUALITY is effectively a rephrase of the closest neighbor and adds no new constraints or concepts.
4. Use similarity scores as a weak signal:
   - if max_score >= 0.90 and the closest neighbor already captures the same meaning, EXISTING is likely.
   - if max_score is medium/high but QUALITY adds a new detail, PARTIALLY_NEW.
   - if max_score is low/medium and content is not covered by neighbors, NEW.
   Scores are not decisive; content is decisive.

Output MUST be valid JSON matching this schema:
{
  "results": [
    {
      "id": <int>,
      "decision": "EXISTING" | "PARTIALLY_NEW" | "NEW",
      "rationale": "string",
      "novel_spans": ["string", ...],
      "matched_neighbor_sentence": "string | null",
      "confidence": 0.0-1.0
    },
    ...
  ]
}

WHERE:
- "novel_spans": short phrases from the QUALITY that represent the new semantic contribution (empty for EXISTING).
- "matched_neighbor_sentence": the single neighbor sentence that is closest in meaning (or null if none).
- "confidence": your confidence in the decision.


Hard requirements:
- Output MUST be strict JSON (double quotes only). Do NOT include markdown.
- The "results" array MUST contain exactly one entry per input item id.
- Each entry MUST preserve the original integer "id".
- Do not invent neighbors; use only what is provided.

############################
FEW-SHOT EXAMPLES (JSON)
############################
$examples_json

############################
NOW CLASSIFY THESE ITEMS (JSON):
############################
$items_json
